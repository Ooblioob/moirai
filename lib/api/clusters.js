// Generated by CoffeeScript 1.9.1
(function() {
  var CLUSTER_DUPLICATE_NAME_ERROR, CLUSTER_MISSING_NAME_ERROR, Promise, _, clusters, couch_utils, doAction, ec2Client, uuid;

  _ = require('underscore');

  Promise = require('pantheon-helpers/lib/promise');

  ec2Client = require('../ec2Client');

  couch_utils = require('../couch_utils');

  uuid = require('node-uuid');

  doAction = require('pantheon-helpers/lib/doAction');

  CLUSTER_MISSING_NAME_ERROR = "Cluster name not provided";

  CLUSTER_DUPLICATE_NAME_ERROR = "Cluster name already exists";

  clusters = {};

  clusters.getCluster = function(db_client, cluster_id, callback) {
    return db_client.use('moirai').get(cluster_id, callback);
  };

  clusters.handleGetCluster = function(req, resp) {
    var cluster_id;
    cluster_id = 'cluster_' + req.params.cluster_id;
    return clusters.getCluster(req.couch, cluster_id).pipe(resp);
  };

  clusters.getClusters = function(db_client, callback) {
    var params;
    params = {
      include_docs: true
    };
    return db_client.use('moirai').viewWithList('moirai', 'active_clusters', 'get_docs', params, callback);
  };

  clusters.handleGetClusters = function(req, resp) {
    return clusters.getClusters(req.couch).pipe(resp);
  };

  clusters.createCluster = function(db_client, record) {
    if (record.name == null) {
      return Promise.reject(CLUSTER_MISSING_NAME_ERROR);
    }
    return clusters.getClusters(db_client, 'promise').then(function(clusterList) {
      console.log(_.findWhere(clusterList, {
        name: record.name
      }));
      if (_.findWhere(clusterList, {
        name: record.name
      }) != null) {
        return Promise.reject(CLUSTER_DUPLICATE_NAME_ERROR);
      }
      record.instances.forEach(function(instance) {
        return instance.id = uuid.v4();
      });
      return doAction(db_client.use('moirai'), 'moirai', null, {
        a: 'c+',
        record: record
      }, 'promise');
    });
  };

  clusters.handleCreateCluster = function(req, resp) {
    var cluster_opts, db;
    cluster_opts = req.body || {};
    db = req.couch.use('moirai');
    return clusters.createCluster(req.couch, cluster_opts).then(function(clusterData) {
      return resp.status(201).send(JSON.stringify(clusterData));
    })["catch"](function(err) {
      if (err === CLUSTER_MISSING_NAME_ERROR) {
        return resp.status(400).send(JSON.stringify({
          error: 'Bad Request',
          msg: err
        }));
      } else if (err === CLUSTER_DUPLICATE_NAME_ERROR) {
        return resp.status(403).send(JSON.stringify({
          error: 'Forbidden',
          msg: err
        }));
      } else {
        return resp.status(500).send(JSON.stringify({
          error: 'Internal Error',
          msg: String(err)
        }));
      }
    });
  };

  clusters.destroyCluster = function(db, cluster_id, callback) {
    return doAction(db, 'moirai', cluster_id, {
      a: 'c-'
    }, callback);
  };

  clusters.handleDestroyCluster = function(req, resp) {
    var cluster_id, db;
    cluster_id = "cluster_" + req.params.cluster_id;
    db = req.couch.use('moirai');
    return clusters.destroyCluster(db, cluster_id).pipe(resp);
  };

  clusters.handleAddInstance = function(req, resp) {
    return resp.send('NOT IMPLEMENTED');
  };

  clusters.handleUpdateCluster = function(req, resp) {
    return resp.send('NOT IMPLEMENTED');
  };

  clusters.setKeys = function(db_client, cluster_id, keys, callback) {
    var db;
    db = db_client.use('moirai');
    return doAction(db, 'moirai', cluster_id, {
      a: 'k',
      keys: keys
    }, callback);
  };

  clusters.handleSetKeys = function(req, resp) {
    var cluster_id, keys;
    cluster_id = 'cluster_' + req.params.cluster_id;
    keys = req.body || [];
    return clusters.setKeys(req.couch, cluster_id, keys).pipe(resp);
  };

  clusters.startCluster = function(db_client, cluster_id, callback) {
    return clusters.getCluster(db_client, cluster_id, 'promise').then(function(cluster) {
      var awsIds;
      awsIds = _.pluck(cluster.instances, 'aws_id');
      return ec2Client.startInstances(awsIds);
    });
  };

  clusters.handleStartCluster = function(req, resp) {
    var cluster_id;
    cluster_id = 'cluster_' + req.params.cluster_id;
    return clusters.startCluster(req.couch, cluster_id).then(function(aws_resp) {
      return resp.status(201).send(JSON.stringify(aws_resp));
    })["catch"](function(err) {
      return resp.status(500).send(JSON.stringify({
        error: 'internal error',
        msg: String(err)
      }));
    });
  };

  clusters.stopCluster = function(db_client, cluster_id, callback) {
    return clusters.getCluster(db_client, cluster_id, 'promise').then(function(cluster) {
      var awsIds;
      awsIds = _.pluck(cluster.instances, 'aws_id');
      return ec2Client.stopInstances(awsIds);
    });
  };

  clusters.handleStopCluster = function(req, resp) {
    var cluster_id;
    cluster_id = 'cluster_' + req.params.cluster_id;
    return clusters.stopCluster(req.couch, cluster_id).then(function(aws_resp) {
      return resp.status(201).send(JSON.stringify(aws_resp));
    })["catch"](function(err) {
      return resp.status(500).send(JSON.stringify({
        error: 'internal error',
        msg: String(err)
      }));
    });
  };

  module.exports = clusters;

}).call(this);
